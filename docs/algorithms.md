# Алгоритмы работы с кучей

## Введение

Куча (heap) - это специализированная древовидная структура данных, которая удовлетворяет свойству кучи: для любого узла i, значение его родительского узла находится в определенном отношении к значению i. Это отношение определяет тип кучи:

- **Минимальная куча (Min Heap)**: Значение родительского узла меньше или равно значениям его дочерних узлов.
- **Максимальная куча (Max Heap)**: Значение родительского узла больше или равно значениям его дочерних узлов.

## Представление кучи в компьютере

Хотя куча концептуально является деревом, она обычно реализуется с использованием массива, что обеспечивает эффективное использование памяти и быстрый доступ к элементам.

### Индексация в массиве

Для узла с индексом `i` в массиве:
- Родительский узел находится по индексу: `(i - 1) / 2`
- Левый дочерний узел находится по индексу: `2*i + 1`
- Правый дочерний узел находится по индексу: `2*i + 2`

Эта схема индексации обеспечивает эффективное представление полного бинарного дерева в виде массива без необходимости хранить указатели на дочерние узлы.

## Основные операции

### 1. Вставка элемента (Insert)

Алгоритм вставки нового элемента в кучу:

1. Добавить новый элемент в конец массива (последний уровень дерева).
2. Сравнить добавленный элемент с его родителем.
3. Если свойство кучи нарушено (для минимальной кучи: если новый элемент меньше родителя; для максимальной кучи: если новый элемент больше родителя), поменять их местами.
4. Повторять шаги 2-3, пока свойство кучи не будет восстановлено или пока не достигнем корня.

Временная сложность: O(log n), где n - количество элементов в куче.

### 2. Извлечение корневого элемента (ExtractRoot)

Алгоритм извлечения корневого элемента (минимального для минимальной кучи, максимального для максимальной кучи):

1. Сохранить значение корневого элемента (индекс 0 в массиве).
2. Переместить последний элемент кучи в корень.
3. Уменьшить размер кучи на 1.
4. Восстановить свойство кучи путем просеивания вниз (sift down).

Временная сложность: O(log n), где n - количество элементов в куче.

### 3. Просеивание вверх (SiftUp)

Алгоритм просеивания вверх используется для восстановления свойства кучи после вставки нового элемента:

1. Начать с добавленного элемента.
2. Сравнить его с родителем.
3. Если свойство кучи нарушено, поменять их местами.
4. Повторять шаги 2-3, пока свойство кучи не будет восстановлено или пока не достигнем корня.

### 4. Просеивание вниз (SiftDown)

Алгоритм просеивания вниз используется для восстановления свойства кучи после удаления корневого элемента:

1. Начать с корневого элемента.
2. Найти наименьший (для минимальной кучи) или наибольший (для максимальной кучи) элемент среди текущего узла и его дочерних узлов.
3. Если этот элемент не текущий узел, поменять их местами.
4. Повторять шаги 2-3 для нового положения узла, пока свойство кучи не будет восстановлено или пока не достигнем листового узла.

### 5. Построение кучи из массива (BuildHeap)

Алгоритм построения кучи из неупорядоченного массива:

1. Начать с последнего родительского узла (индекс n/2 - 1, где n - размер массива).
2. Выполнить просеивание вниз для этого узла.
3. Двигаться к предыдущему узлу и повторять шаг 2, пока не достигнем корня (индекс 0).

Временная сложность: O(n), где n - количество элементов в массиве.

## Алгоритм окучивания массива (Heapify)

Окучивание (heapify) - это процесс преобразования массива в кучу, удовлетворяющую свойству кучи. Существует два основных подхода:

### 1. Окучивание сверху вниз

1. Начать с пустой кучи.
2. Последовательно вставлять элементы из исходного массива в кучу, используя операцию вставки.

Временная сложность: O(n log n), где n - количество элементов в массиве.

### 2. Окучивание снизу вверх (более эффективный)

1. Рассматривать массив как полное бинарное дерево.
2. Начать с последнего родительского узла (индекс n/2 - 1).
3. Выполнить просеивание вниз для каждого узла, двигаясь к корню.

Временная сложность: O(n), где n - количество элементов в массиве.

## Пирамидальная сортировка (HeapSort)

Алгоритм сортировки кучей:

1. Построить максимальную кучу из исходного массива (для сортировки по возрастанию).
2. Поменять местами корневой элемент (максимальный) с последним элементом кучи.
3. Уменьшить размер кучи на 1 (исключить последний элемент из рассмотрения).
4. Восстановить свойство кучи для корня (просеивание вниз).
5. Повторять шаги 2-4, пока размер кучи не станет равным 1.

Временная сложность: O(n log n), где n - количество элементов в массиве.

## Применения кучи

1. **Сортировка**: Пирамидальная сортировка (HeapSort).
2. **Очереди с приоритетом**: Эффективная реализация очередей с приоритетом.
3. **Алгоритм Дейкстры**: Для поиска кратчайшего пути в графе.
4. **Алгоритм Прима**: Для построения минимального остовного дерева.
5. **Планирование задач**: В операционных системах для планирования процессов.
6. **Поиск k-го наименьшего/наибольшего элемента**: Эффективный алгоритм выбора.

## Заключение

Куча является мощной и эффективной структурой данных с широким спектром применений. Её представление в виде массива обеспечивает компактность и эффективность операций, а алгоритм окучивания позволяет быстро преобразовать произвольный массив в кучу.
